## Redis如何删除过期Key

- 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- 惰性删除：读取到数据时，发现数据已经过期，则删除这个Key。

**产生的问题** ：  
如果Key很多，定期删除没有来得及扫描到过期的Key，而这些数据又没有被读取，这样就不会被删除，在内存中形成的垃圾数据，这时候怎么办呢？就是下面的内存淘汰机制。

## 内存淘汰机制

- **volatile-lru** ：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- **volatile-ttl** ：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- **volatile-random** ：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- **allkeys-lru** ：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
- **allkeys-random** ：从数据集（server.db[i].dict）中任意选择数据淘汰
- **no-eviction** ：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！
4.0版本后增加以下两种：
- **volatile-lfu** ：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
- **allkeys-lfu** ：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

更多：[Redis内存淘汰机制](Redis内存淘汰机制.md)

## 缓存雪崩

缓存同一时间失效导致去查询数据库。

**解决：**  
- Redis服务器正常，缓存同时过期：
	- 可以在过期时间上加上随机数，避免大面积失效。
	- 可以设置缓存永久不过期并采取适当的内存淘汰机制，如秒杀过后要删除无用的缓存。
	- 增加限流或降级策略，保证MySQL稳定。
- Redis服务器挂掉：
	- 增加服务器实例保证可用性。
	- 利用持久化恢复。

## 缓存穿透

虚假数据请求导致认为缓存不存在去查询数据库。

**解决：**  
- 将不存在的Key缓存为Null，下次就可以不走DB。（浪费内存，也并不能保证下次请求会来）
- 做一些风控安全限制。（同一时间IP、请求次数等限制）
- 使用布隆过滤器进行过滤。（推荐）将有缓存的数据都放到布隆过滤器中，请求来时Cache不存在，查询布隆过滤器就知道DB中是否存在。

## 缓存击穿

缓存的都不是非热点数据导致去查询数据库。

**解决：**  
优化热点数据的计算方式。淘汰缓存中的非热点数据。

## 如何解决 Redis 的并发竞争 Key 问题

所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

**解决：**  
- 放到有序的消息队列中一次操作。
- 使用分布式锁对Key进行顺序操作。