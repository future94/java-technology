
## 1. 背景

秒杀情况一般都是大量客户在请求，实际抢到成交很少，而且价格很便宜一般都会付钱，所以一般都是下单时就减库存的方案，而且秒杀起到引流宣传的作用，所以即使个别用户不付钱，实际上影响也是比较小的。

## 2. 页面静态化

秒杀开始前几分钟，大量用户开始进入秒杀商品详情页面，很多人开始频繁刷新秒杀商品详情页，这时秒杀商品详情页访问量会猛增。秒杀商品都是提前计划好的，所以可以将秒杀页面静态化，上传到CDN中或者nginx层生成静态页面缓存，让秒杀开始之前的请求不用经过后台处理。

![image](https://raw.githubusercontent.com/future94/java-technology/master/case/seckill/images/hiu1231231.png)

## 3. 请求限流

由于请求人比较多，但实际能成功下单的人比较少，所以网络压力一般都在网关层面。

首先，我们可以在前端做请求限制，如秒杀开始之前不能提交请求，秒杀失败之后不能在请求。

其次，我们可以在网关层面做请求限制，如我们有200件商品，我们可以放200个请求到后台服务。我们还可以采用分段放行的机制，避免最开始有很多机器人刷新。如每隔100毫秒放行10个请求，这样2秒就可以放完所有，又不影响用户体验。

最后，我们还可以对网关做集群处理来分摊限流的压力。

## 4. 后端设计

如果我们只买200个产品，那么经过网关的限流，到后端服务器也没有多少压力了。如果我们秒杀2w个产品，那后端服务器压力还是很大的。

我们可以采用排队的方式异步下单，将这些到后端的用户放到队列中，并告诉他们自己在队列中所处的位置，然后在通过MQ削峰慢慢下单。也可以采用批量下单的方式缓解数据库同时大量写入的问题。

我们还要防止超卖情况，有兴趣可以查看：[秒杀超卖情况解决方案](秒杀超卖情况解决方案.md)

## 5. 服务隔离

为了不影响正常业务的运行，我们可以将秒杀服务和其他服务隔离开来，

- 业务隔离。由于秒杀商品提交都知道，我们可以将这些商品和普通商品区分开，如详情页静态化等等。
- 服务隔离。为了不影响其他服务正常提供，我们可以将秒杀服务单独部署。
- 数据隔离。可以将秒杀用的数据库、Redis等和正常业务区分开，增加其吞吐量，并且不影响正常业务。