## 总结
 | XA | AT | TCC | Saga | 可靠消息 | 最大努力通知
---|---|---|---|---|---|---
数据一致性 | 强一致性 | 强一致性 | 补偿型 | 补偿型 | 最终一致性 | 最终一致性
隔离性 | 满足 | 满足 | 不满足 | 不满足 | 不满足 | 不满足
代码入侵性 | 低 | 低 | 高 | 低 | 中 | 中
性能 | 最低。同步阻塞执行，分布式事务结束在释放各个分支事务资源 | 低。同步阻塞执行，拿到全局锁后再能提交分支事务 | 中。先执行各个方法的Try，在执行事务的Commit或者Rollback，基于业务实现，不持有资源锁 | 高。长事务解决方案，基于状态机可以实现容器编排并发执行 | 高。基于MQ可以实现长事务的异步和解偶 | 高。基于MQ可以实现长事务的异步和解偶
实现 | 完全基于数据库 | 基于数据库，并会生成undo log | 基于业务，实现Try、Commit、Rollback接口 | 基于状态机流转将分布式事务拆为各个分支事务 | 生产者层面。生产者发送可靠的消息到MQ中间件 | 消费者层面。生产者尽最大努力发送消息，并提供查询接口供消费者最终确认。


## 1. 什么是分布式事务？

在现在微服务架构中，操作数据的服务不是同一个服务，存储的数据的工具也不止同一个，底层的数据库也不止同一个。要保证这个链路下来数据的一致性，即要么成功要么失败，这样服务数据才不会出错。

## 2. 分布式系统的CAP定理

- C（Consistency）一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
- A（Availability）可用性：保证每个操作都必须以可预期（成功或者失败都可以）的响应结束。
- P（Partition tolerance）分区容错性。系统中任意信息的丢失或失败不会影响系统的继续运作。

三者无法同时满足，注意取舍。

### 2.1 一致性Consistency

- 强一致性：写入什么就要就要读出什么，没有延迟。用户体验最好，但是性能消耗很高。
- 弱一致性：尽量在一段时间后，将数据尽可能的达到一致的状态。
- 最终一致性：算是弱一致性的特例，在一定时间后，将数据达到最终一致的状态。

### 2.2 可用性Availability

在有限的时间内，对请求返回一个可以确定的结果，成功或者失败均可，如返回超时这种请求不知道是成功了失败了，则为不可用服务。

“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果，不论这个结果是成功还是失败。

### 2.3 分区容错性Partition tolerance

这个是分布式中的重要概念，分布式就是为了达到分区容错性。即当一个分区的数据或服务挂掉之后，不会影响整体数据或服务的运行。

## 3. BASE定理

base定理是对AP的延伸，在我们满足AP的前提下，通过采取合适的方式达到最终一致性来保证分布式系统的CAP。

<font color="red">BASE理论是提出通过牺牲一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</font>。

- 基本可用（Basically Available）：当系统出现问题时，允许部分不可用，但不能系统整体不可用。
- 软状态（Soft State）：允许系统中存在中间状态，如创建、处理中、成功、失败，可以存在处理中的中间状态，但最后要变成最终态。
- 最终一致性（Eventually consistent）：经过一段时间的流转之后，需要系统保证最终数据能够达到一致。

## 4. 分布式事务分类

- 刚性事务：满足CP原则。
- 柔性事务：满足base定理的AP原则。

## 5. 2PC两阶段提交协议

2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。

成功情况：
![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/WX20210915-231312.png)

失败情况：
![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/WX20210915-151045.png)

### 5.1 准备阶段

事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。

### 5.2 提交阶段

如果都接收到了成功消息，则事务管理器给每个参与者发送Commit信息，反之发送Rollback消息。只有在收到Commit/Rollback后才会释放资源锁。

### 5.3 2pc优缺点

**优点**：
尽量保证数据的强一致性。

**缺点**：
- 同步阻塞：事务执行阶段是全局锁住的，执行完成之后（Commit与Rollback）才会释放资源锁。
- 单点故障：一旦协调者发生故障。参与者会一直阻塞下去。
- 数据一致性：这个也是2PC无法解决的问题，如果某一个参与者commit或者rollback失败，那么会数据不一致。

## 6. 3PC三阶段提交协议

<font color="red">3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题</font>。

作为2PC的改进版，3PC三阶段提交协议在协调者和参与者中都引入 超时机制，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。三阶段提交的三个阶段分别为：can_commit，pre_commit，do_commit。

![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/20191210222510777.png)

**3PC主要解决的单点故障问题** ：
相对于2PC，3PC主要解决的单点故障问题，并减少阻塞， 因为<font color="red">一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态</font>。

但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort(终止)响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。

**3PC相对于2PC而言到底优化了什么地方呢** :
相比较2PC而言，3PC对于协调者（Coordinator）和参与者（Partcipant）都设置了超时时间，而2PC只有协调者才拥有超时机制。这解决了一个什么问题呢？

这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。

## 7. XA方案

XA是一个2PC，为了规范2PC的实现，国际开放标准组织Open Group定义了分布式事务处理模型 DTP（Distributed Transaction Processing Reference Model），即：XA。MySQL、Oracle等都实现了这个方案，就是事务。

DTP模型定义如下角色：
- AP（Application Program）：应用程序。需要执行分布式事务的程序代码。
- TM（Transaction Manager）：事务管理器。管理和协调分布式事务，负责确定RM的Commit还是Rollback。
- RM（Resource Manager）：资源管理器。对数据库资源进行操作管理。

TM如何管理、接收RM消息呢？就是通过XA接口。所以<font color="red">XA方案就是规定了RM与TM数据传输的协议</font>。

**XA方案优缺点**：
XA方案就是标准的2PC，所以与2PC的优缺点一致。并且XA方案需要数据库支持本地事务。

## 8. Seata AT方案

**产生背景：**  
Seata AT方案XA方案的一个变种，由于XA在分布式事务执行中，会持有资源锁，当分布式事务执行完成之后才会进行资源锁的释放导致性能很低，所以Seata AT方案可以解决资源锁的释放问题。当一个参与者执行成功之后，直接提交事务并释放资源锁，生成undo log日志。

**Seata模型中定义的角色：**  
- TC（Transaction Coordinator）：事务协调器。事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚。
- TM（Transaction Manager）：事务管理器。TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向TC发起全局提交或全局回滚的指令。
- RM（Resource Manager）：资源管理器。控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分支（本地）事务的提交和回滚。

**以用户注册送积分方式理解AT：**  
![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/dhu21312.png)

- 用户服务的TM向TC申请开启一个全局事务，并拿到全局唯一的事务XID。
- 用户服务RM向TC注册分支事务，并归入刚才创建的全局事务XID中。
- 用户服务RM执行分支事务，并创建undo log日志（由代理解析sql实现），将执行结果上报给TC。
- 用户服务调用积分服务，并携带XID。
- 积分服务获取到XID，积分服务的RM向TC注册分支事务，并归入刚才获取到XID的全局事务中。
- 积分服务RM执行分支事务，并创建undo log日志，将执行结果上报给TC。
- 用户服务调度完成之后，向TC请求该XID的最后决议（Commit或Rollback）。
- TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。
	- 提交：因为之前都已经提交过了，直接删除undo log日志即可。
	- 回滚：根据undo log里的日志生成反向sql进行回滚，回滚之前需要检验，如果一致，则反向回滚，如果不一致，则需要人工介入处理。

**全局锁：**
分支事务执行事务提交操作时，必须获取到全局锁才能提交，通过全局锁来保证数据库事务的执行顺序，如上图：肯定是用户服务先拿到全局锁提交事务释放全局锁，然后积分服务才能拿到全局锁提交事务。

**Seata AT的优缺点**：  
**优点**：相比与传统的XA，分支事务执行完成时候会直接提交，不会占用资源锁等待全局事务的最终结果之后在释放，提高了性能。

**缺点**：
- 通过SQL解析来生成undo log日志，对于各种数据库sql都要进行适配。
- 有全局锁的概念，各分支事务如果像提交，还是要同步等待拿到全局锁之后才能提交。

## 9. TCC方案

TCC与2PC和3PC区别在于2PC是在数据库层面的，而<font color="red">TCC是基于业务层面的，属于补偿型事务</font>。

**处理流程：**
- 预处理Try。Try操作做业务检查及资源预留。
- 确认Conﬁrm。Conﬁrm做业务确认操作
- 撤销Cancel。Cancel实现一个与Try相反的操作即回滚操作。

TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Conﬁrm操作，其中Conﬁrm/Cancel操作若执行失败，TM会进行重试。TCC也是要求强一致的，有一个失败就要回滚，而且由于异步的原因，每个操作都要实现幂等。

![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/1bf0b27725f15029.png)

**TCC要解决的问题：**
1. **允许空补偿**
	- 空补偿：Try未执行，Canel执行了
	- 出现原因：
		- 原服务 超时（丢包）
		- 事务触发 回滚
		- 未收到 原服务请求，先收到 补偿请求

所以服务设计时需要允许空补偿, 即没有找到要补偿的业务主键时返回补偿成功并将原业务主键记录下来

2. **防悬挂控制**
	- 悬挂：先执行Canel后执行Try
	- 出现原因：
		- 原服务 超时（拥堵）
		- 事务回滚，触发 回滚
		- 拥堵的 原服务 到达

所以要检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝服务的执行

3. **幂等控制**
- 原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新

**TCC方案的优缺点：**
优点：
- 不会阻塞，也不会像AT那样通过undo log进行回滚，无须解析sql通用性强且效率高。
- TCC是基于业务层面的最终一致性的方案，不会长时间持有锁，性能比较强，在金融领域通过try和通过补偿机制来保证资金的正确性。如转账时先会冻结一部分余额。
- 可以跨业务实现，不需要对数据源有要求。

缺点：
- 由于基于业务实现，所以代码入侵性比较大，而且基于固定业务实现，耦合严重。
- 对于各种情况都要提供补偿机制，并且实现幂等。


## 10. SAGA方案

Saga模式是一种长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。

![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/TB1Y2kuw7T2gK0jSZFkXXcIQFXa-445-444.png)

Saga模型是把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（对应TCC中的Confirm和Cancel），当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性。

这样的SAGA事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性。

**Saga两种恢复策略**：
- 向后恢复：有一个执行失败之后，撤销掉之前所有成功子事务，即执行补偿操作。
- 向前恢复：有一个执行失败之后，进行重试操作直到成功，适用于必须成功的场景。

Saga不提供ACID保证，因为原子性和隔离性不能得到满足。通过saga log，saga可以保证一致性和持久性。

Saga和TCC一样也需要允许空补偿、防止悬挂、幂等处理，而且Saga的隔离性也需要做应对。

**缺乏隔离性的应对**
由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作, 比如举一个极端的例子, 分布式事务内先给用户A充值, 然后给用户B扣减余额, 如果在给A用户充值成功, 在事务提交以前, A用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题, 实践中一般的应对方法是：
- 业务流程设计时遵循“宁可长款, 不可短款”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在业务流程设计上一定是先扣款。
- 有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。

更多：[微服务架构设计模式-使用Saga管理事务](https://blog.csdn.net/ylnlp5602260/article/details/113809953)

## 11. 可靠消息最终一致性方案

要求消息中间件是可靠的，事务发起方执行本地事务并发送消息，事务另一方保证消费消息，以此来保证数据的最终一致性。

如用户注册送积分业务，用户服务的用户注册和发送增加基本消息到MQ要求是原子的，并且积分服务要保证可以消费完成这个消息，达到数据的最终一致性。

```txt
// 保证下面两个方法执行的原子性
userService.register();
mqTemplate.send();
```

### 11.1 实现方式
#### 11.1.1 本地消息表

增加消息发送表，通过本地事务实现用户注册和消息表的插入，然后通过定时任务重试的方式保证MQ消息的准确投递。消费端一定消费可以通过MQ支持的ACK机制保证消息被消费。

![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/38d33497287b4178bb961fb97bafa65a.png)

#### 11.1.2 RocketMQ半消息

我们先想MQ发送一个半消息（一种特殊的还没有被确定的消息，不会投递给消费者消息，必须要在确认之后），MQ会回掉告诉我们半消息发送成功，这时候我们在回掉中执行代码逻辑（如上面的用户注册功能），并回复半消息为Commit状态，MQ就会将消息投递给消费者消费。如果MQ回掉我们半消息发送成功超时等情况，还会用过检查机制，回掉我们校验这个半消息的最终状态。

![image](https://raw.githubusercontent.com/future94/java-technology/master/database/transaction/images/dhuhiu1239.png)

### 11.2 优缺点
优点：
- 性能高，分布式事务不需要同步等待。
- 对大事务可以起到解偶的作用。

缺点：
- 代码需要改造。
- 不能保证数据强一致。

## 12. 最大努力通知方案

与上面可靠消息最终一致性方案不同，最大努力通知方案由接收方来保证最终一致性。

如用户充值送积分业务，充值尽可能的通知积分服务，如果积分服务确实收不到消息，则提供查询接口，由接收方（积分服务）来保证消息的最终一致性。

### 12.1 实现方式

#### 12.1.1 本地消息表

增加消息通知表，通过本地事务实现用户注册和通知表的插入，然后通过定时任务重试的方式保证消息的准确投递。消费端通过发送端提供的查询接口保证消息数据的最终一致性。

#### 12.1.2 MQ通知

- 生产端通过MQ实现延时队列功能进行最大努力通知。
- 消费端通过发送端提供的查询接口保证消息数据的最终一致性。
	- 可以监听MQ消息来消费并查询。适用于内部系统。
	- 可以由通知服务监听MQ并查询，并通知给消费者。适用于通知外部系统。

### 12.2 优缺点
优点：
- 性能高，分布式事务不需要同步等待。
- 对大事务可以起到解偶的作用。
- 可以应对外部系统代码无法更改的情况。

缺点：
- 代码需要改造。
- 不能保证数据强一致。


区别 | 可靠消息最终一致性 | 最大努力通知
---|---|---
最终一致性 | 要求发送者一定要将消息发送出去，让消费者可以消费 | 发送者尽最大可能发送，如果收不到，由发送者提供查询接口供消费者最终确定
场景 | 一般是系统内部最终一致 | 一般是外部系统，如微信支付回掉


参考文章：
- [黑马程序员分布式事务控制解决方案从入门到应用，微服务分布式系统开发教程](https://www.bilibili.com/video/BV1Q4411y7ip)
- [分布式事务面试题](https://www.cnblogs.com/crazymakercircle/p/14375424.html)
- [分布式事务专题](https://blog.csdn.net/hancoder/article/details/120213532)
- [SEATA Saga 模式](http://seata.io/zh-cn/docs/user/saga.html)